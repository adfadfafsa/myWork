<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // .push() = 뒤에 삽입
        // .pop() = 뒤에 삭제
        // .unshift() = 앞에 삽입
        // .shift() = 앞에 삭제

        // 1. .splice(n,m,x) = n번 인텍스부터 m개 지우고(0 넣으면 지우지 않음) 그 자리에 x 추가 (안쓰면 지우기만함)
        //    ->값을 반환할 시에는 오히려 삭제된 요소를 반환
        // 2. .slice(n,m) = n번 인덱스부터 m 바로 전 인덱스까지 반환
        // 3. .concat() = 배열을 합쳐서 새 배열로 반환
        // 4. .forEach(함수) = 배열의 반복
        // 5. .indexOf() = 찾는 배열 요소의 인덱스 넘버 표시
        // 6. .lastIndexOf = 배열 요소의 인덱스 넘버를 끝에서부터 찾아 표시
        // 7. .includes() = 포함하는지 확인
        // 8 .find(fn) / findIndex(fn) = 배열 요소가 함수에 들어갔을 때 true인 첫번째 요소 표시 / 요소 인덱스 표시
        //    ->첫번째 true값만 반환함, 없으면 undefined
        // 9. .filter(fn) = 만족하는 모든 요소를 배열로 반환
        // 10. .reverse() = 배열을 역순으로 재정렬
        // 11. ★.map(fn) = 함수를 받아 특정 기능을 시행하고 새로운 배열로 반환★
        // 12. .join = 요소들을 전부 합친 문자열로 만듬 (근데 계속 반점찍힘. 구분자 설정 해줘야함)
        // 13. .split = 문자열을 구분자 기준으로 나눠 전부 요소로 만들어준다
        // 14. Array.isArray() = 배열인지 확인 (typeof는 배열도 Object로 뜸)
        
        
        // 1. .splice
        //  -> 값을 반환할 시에는 오히려 삭제된 요소를 반환
        let arr = [1, 2, 3, 4, 5];
        arr.splice(1, 3, 100, 200);
        console.log(arr); // [1, 100, 200, 5] //일단 splice만 해서 자르고 추가한 결과를 보여줌
        let result = arr.splice(1,2)
        console.log(result) // [100, 200] // splice 반환 값이 result라서 삭제된 요소를 반환함
        
        // 2. .slice
        let arr2 = [1, 2, 3, 4, 5];
        arr2.slice(1,4); // [2, 3, 4]
        let arr3 = arr2.slice();
        console.log(arr3) // [1, 2, 3, 4, 5] //arr2.slice() <- 공백 넣어서 그냥 그대로 나왔음
        
        // 3. .concat
        let arr4 = [1,2];
        arr5 = arr4.concat([3,4],[5,6],7); // [1,2,3,4,5,6,7] //배열이나 넘버 뭘로 추가해도 상관없음
        
        // 4. .forEach
        let users = ['Mike', 'Tom', "Jane"]
        users.forEach((name, index) => { // .forEach((배열의 요소들, 인덱스){명령})
        console.log(`${index + 1}.${name}`);
    })
    
        // 5. .indexOf
        let arr6 = [1,2,3,4,5,1,2,3]
        arr6.indexOf(3,5) // 7 // 값 3을 찾는데 인덱스 5번부터만 찾아라
        arr6.lastIndexOf(3) // 7 // 맨 뒤에서부터 찾는 값 3은 7번에 있음

        // 6. .lastIndexOf

        // 7. .includes
        let arr7 = [1,2,3]
        arr.includes(2); // true
        arr.includes(8); // false

        // 8,9. .find(fn) , findIndex(fn), .filter(fn)
        let arr8 = [1,2,3,4,5,6]
        const result2 = arr.find((item) => { //여기 메소드 들어갔음
            return item % 2 === 0; 
        })
        // 결과값 : .find(fn) 이면 2, findIndex(fn) 이면 1, .filter(fn) 이면 [2,4,6]
        
        // 10. .reverse()
        let arr9 = [1,2,3,4,5]
        arr9.reverse(); // [5,4,3,2,1]

        // 11. .map(fm)
        let userList = [
            {name: "Mike", age: 30},
            {name: "Jane", age: 27},
            {name: "Tom", age: 10}
        ]
        let newUserList = userList.map((user,index) => {
            return Object.assign({}, user, {  // object 메소드 사용
                id: index + 1,
                isAdult: user.age > 19
            })
        })
        console.log(newUserList)

        // 12. .join
        let arr10 = ["안녕", "나는", "철수야"]
        let result3 = arr.join() // 안녕,나는,철수야 //구분자 공백
        let result4 = arr.join(" ") // 안녕 나는 철수야

        // 13. .split
        const users2 = "Mike,Jane,Tom,Tony"
        const result5 = users2.split(",") // ["Mike", "Jane", "Tom", "Tony"] //구분자 ","

        // 14. Array.isArray()
        let user = {
            name: "Mike",
            age: 30
        } // 객체인데 typeof 에서 object로 뜸
        let userList2 = ["Mike","Tom"," Jane"] // 배열인데 typeof에서 object로 뜸
        Array.isArray(user) // false
        Array.isArray(userList2) // true

    </script>
</body>
</html>